import java_cup.runtime.*;
import java.util.*;
import java.io.*;

// operations
terminal PLUS, TIMES, MINUS,DIVIDE, CONCAT, ASSIGN;
//types
terminal FLOAT, INTEGER,STRING,CHAR,BOOL, ID;
//type definitions
terminal FLOATTYPE, INTEGERTYPE, STRINGTYPE, CHARTYPE, LISTTYPE, TUPLETYPE, BOOLTYPE; 
// punctutation
terminal  DOT, COMMA, COLON, STROKE,LCBRACK, RCBRACK,LPAREN, RPAREN,SEMI,LBRACK,RBRACK;
//keywords
terminal LEN, VOID,FDEF, IF, ELSE, WHILE, REPEAT, RETURN, UNTIL, DO, IN;
//logica operations
terminal OR, AND, NOT;
//comparison
terminal EQ, LESS, GREATER, LESSEQ, GREATEREQ, NEQ;
//data type declaration
terminal TDEF;  

non terminal name, simple_name, qualified_name, type, element;
non terminal type_declr,element_list;   //Data type declaration
non terminal list, emptyList, listOfListsOfStrings, listOfListsOfIntegers, listOfListsOfFloats, listOfListsOfChars,valuelist, listOfListsOfBools, listOfListsOfVars, value;
non terminal stringList, floatList, integerList, charList,boolList,varList;
non terminal listOfChars, listOfIntegers, listOfFloats, listOfStrings, listOfBools, listOfVars;
non terminal tuple, emptyTuple;
non terminal list_index, sequence_len, sequence_slicing, in_expression;

non terminal expression,primary,primary_no_new_array,multiplicative_expression,additive_expression;

non terminal concat_expr;

non terminal assignment, if_statement, else_statement, else_opt, while_statement, repeat_statement, return_statement;



nonterminal func_def_retrn, func_def_noretrn, param_list, body, body_op, method_invocation;
non terminal var_declr, statement, statement_list, variable_declarator, variable_initializer,argument_list,argument_list_opt;

non terminal unary_expression, unary_expression_not_plus_minus,postfix_expression,shift_expression, relational_expression,equality_expression;
non terminal conditional_expression, conditional_or_expression, assignment_expression, left_hand_side, and_expression;

non terminal declaration, declarations_list, program;


precedence left PLUS;
precedence left TIMES;

start with program;

name	::=	simple_name {:System.out.println("name ::= simple_name");:}
	|	qualified_name {:System.out.println("name ::= qualified_name");:} ;
simple_name ::=	ID {:System.out.println("simple_name ::= ID");:};
//compound name, i.e id.field
qualified_name ::=
		name DOT ID {:System.out.println("qualified_name ::= name DOT ID");:}
		| list_index {:System.out.println("qualified_name ::= list_index");:};

value ::= BOOL {: System.out.println("value ::= BOOL"); :}
	  | INTEGER {: System.out.println("value ::= INTEGER"); :}
	  | FLOAT {: System.out.println("value ::= FLOAT"); :}
	  | CHAR {: System.out.println("value ::= CHAR"); :}
	  | STRING {: System.out.println("value ::= STRING"); :}
	  | list {: System.out.println("value ::= list"); :}
	  | tuple {: System.out.println("value ::= tuple"); :};
valuelist ::= value {: System.out.println("valuelist ::= value"); :}
			| valuelist COMMA value {: System.out.println("valuelist ::= valuelist value"); :};
//any list
list ::= emptyList {:System.out.println("list ::= emptyList");:}
	| stringList {:System.out.println("list ::= stringList");:}
	| integerList {:System.out.println("list ::= integerList");:}
	| floatList {:System.out.println("list ::= floatList");:}
	| charList {:System.out.println("list ::= charList");:}
	| boolList {:System.out.println("list ::= boolList");:}
	| varList {:System.out.println("list ::= varList");:};
//empty list, i.e []
emptyList ::= LBRACK RBRACK {:System.out.println("emptyList ::= LBRACK RBRACK");:};
//string list, i.e ["item1","item2"] or [["item1"],["item2"]] etc
stringList ::= LBRACK listOfStrings RBRACK {:System.out.println("stringList ::= LBRACK listOfStrings RBRACK");:}
	| LBRACK listOfListsOfStrings RBRACK {:System.out.println("stringList ::= LBRACK listOfListsOfStrings RBRACK");:}; 
//list of lists of strings, i.e ["item1"],["item2"]
listOfListsOfStrings ::= stringList {:System.out.println("listOfListsOfStrings ::= stringList");:}
	| stringList COMMA listOfListsOfStrings {:System.out.println("listOfListsOfStrings ::= stringList COMMA listOfListsOfStrings");:};
//list of strings, i.e "item1","item2"
listOfStrings ::= STRING {:System.out.println("listOfStrings ::= STRING");:}
	| STRING COMMA listOfStrings {:System.out.println("listOfStrings ::= STRING COMMA listOfStrings");:};
//integer list, i.e [1,2,3] or [[1],[2],[3]] etc
integerList ::= LBRACK listOfIntegers RBRACK {:System.out.println("integerList ::= LBRACK listOfIntegers RBRACK");:}
	| LBRACK listOfListsOfIntegers RBRACK {:System.out.println("integerList ::= LBRACK listOfListsOfIntegers RBRACK");:}; 
//list of list of integers, i.e [1,2,3],[1,2,3]
listOfListsOfIntegers ::= integerList {:System.out.println("listOfListsOfIntegers ::= integerList");:}
	| integerList COMMA listOfListsOfIntegers {:System.out.println("listOfListsOfIntegers ::= integerList COMMA listOfListsOfIntegers ");:};
//list of integers, i.e 1,2,3
listOfIntegers ::= INTEGER {:System.out.println("listOfIntegers ::= INTEGER");:}
	| INTEGER COMMA listOfIntegers {:System.out.println("listOfIntegers ::= INTEGER COMMA listOfIntegers");:};
//float list, i.e [1.2,3.4,1.5] or [[2.4],[2.2],[5.3]] etc
floatList ::= LBRACK listOfFloats RBRACK {:System.out.println("floatList ::= LBRACK listOfFloats RBRACK");:}
	| LBRACK listOfListsOfFloats RBRACK {:System.out.println("floatList ::= LBRACK listOfListsOfFloats RBRACK");:}; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfFloats ::= floatList {:System.out.println("listOfListsOfFloats ::= floatList");:}
	| floatList COMMA listOfListsOfFloats {:System.out.println("listOfListsOfFloats ::= floatList COMMA listOfListsOfFloats");:};
// list of floats, i.e 2.6,4.2,6.2
listOfFloats ::= FLOAT {:System.out.println("listOfFloats ::= FLOAT");:}
	| FLOAT COMMA listOfFloats {:System.out.println("listOfFloats ::= FLOAT COMMA listOfFloats");:};
//float list, i.e [1.2,3.4,1.5] or [[2.4],[2.2],[5.3]] etc
boolList ::= LBRACK listOfBools RBRACK {:System.out.println("boolList ::= LBRACK listOfBoolss RBRACK");:}
	| LBRACK listOfListsOfBools RBRACK {:System.out.println("boolList ::= LBRACK listOfListsOfBools RBRACK");:}; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfBools ::= boolList {:System.out.println("listOfListsOfBools ::= boolList");:}
	| boolList COMMA listOfListsOfBools {:System.out.println("listOfListsOfBools ::= boolList COMMA listOfListsOfBools");:};
// list of floats, i.e 2.6,4.2,6.2
listOfBools ::= BOOL {:System.out.println("listOfFloats ::= BOOL");:}
	| BOOL COMMA listOfBools {:System.out.println("listOfBools ::= BOOL COMMA listOfBools");:};
// list of variables
varList ::= LBRACK listOfVars RBRACK {:System.out.println("boolList ::= LBRACK listOfBoolss RBRACK");:}
	| LBRACK listOfListsOfVars RBRACK {:System.out.println("boolList ::= LBRACK listOfListsOfBools RBRACK");:}; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfVars ::= varList {:System.out.println("listOfListsOfVars ::= varList");:}
	| varList COMMA listOfListsOfVars {:System.out.println("listOfListsOfVars ::= varList COMMA listOfListsOfVars");:};
// list of floats, i.e 2.6,4.2,6.2
listOfVars ::= name {:System.out.println("listOfVars ::= name");:}
	| name COMMA listOfVars {:System.out.println("listOfVars ::= name COMMA listOfVars");:};



//char list, i.e ['1','4','5'] or [['s'],['e'],['d']] etc
charList ::= LBRACK listOfChars RBRACK {:System.out.println("charList ::= LBRACK listOfChars RBRACK");:}
	| LBRACK listOfListsOfChars RBRACK {:System.out.println("charList ::= LBRACK listOfListsOfChars RBRACK");:}; 
//list of list of chars, i,e ['4','2','d'], ['e','5','s']
listOfListsOfChars ::= charList {:System.out.println("listOfListsOfChars ::= charList");:}
	| charList COMMA listOfListsOfChars {:System.out.println("listOfListsOfChars ::= charList COMMA listOfListsOfChars");:};
// list of chars, i.e '2','3','j'
listOfChars ::= CHAR {:System.out.println("listOfChars ::= CHAR");:}
	| CHAR COMMA listOfChars {:System.out.println("listOfChars ::= CHAR COMMA listOfChars");:};

//empty tuple
emptyTuple ::= LBRACK OR RBRACK {:System.out.println("emptyTuple ::= LBRACK STROKE STROKE RBRACK ");:};
//tupple
tuple ::= emptyTuple  {:System.out.println("tuple ::= emptyTuple");:}
	| LBRACK STROKE valuelist STROKE RBRACK {:System.out.println("tuple ::= LBRACK STROKE valuelist STROKE RBRACK");:};
	//| LBRACK STROKE tuple COMMA tuple STROKE RBRACK {:System.out.println("tuple ::= LBRACK STROKE listOfAnyElements STROKE RBRACK");:};


declaration ::= 
	 type_declr
	| var_declr
	| func_def_retrn
	| func_def_noretrn;

declarations_list ::= declarations_list declaration
	| declaration;


type_declr ::= TDEF ID COLON element_list SEMI {: System.out.println("typedecl ::= TDEF ID COLON element_list SEMI"); :}
	;	
	
element_list ::= element {: System.out.println("element_list ::= element"); :}
	| element_list COMMA element {: System.out.println("element_list ::= element_list COMMA element"); :}
	;
	
element ::= ID COLON type {: System.out.println("element ::= ID COLON type"); :}
	| ID COLON ID
	;


var_declr ::= 
		 variable_declarator SEMI {:System.out.println("var_declr ::= ID COLON variable_declarator SEMI");:}
	;
	
variable_declarator ::=
		element {:System.out.println("variable_declarator ::= element ");:}
	|	element ASSIGN variable_initializer {:System.out.println("variable_declarator ::= element ASSIGN variable_initializer ");:}
	;
	
	
variable_initializer ::=
		expression {:System.out.println("variable_initializer ::= expression ");:}
		| variable_initializer COMMA expression
	;	

type ::= FLOATTYPE {:System.out.println("type ::= FLOATTYPE");:}
	| INTEGERTYPE {:System.out.println("type ::= INTEGERTYPE");:}
	| CHARTYPE {:System.out.println("type ::= CHARTYPE");:}
	| BOOLTYPE {:System.out.println("type ::= BOOLTYPE");:}
	| STRINGTYPE {:System.out.println("type ::= STRINGTYPE");:}
	| LISTTYPE {:System.out.println("type ::= LISTTYPE");:}
	| TUPLETYPE {:System.out.println("type ::= TUPLETYPE");:}
	;

// 19.12) Expressions
primary ::=	primary_no_new_array {: System.out.println("primary ::= primary_no_new_array"); :}
	;
primary_no_new_array ::=
		value {: System.out.println("primary_no_new_array ::= value"); :}
	|	LPAREN expression RPAREN
	|   sequence_len
	|	method_invocation
	;


argument_list_opt ::=
	|	argument_list
	;
argument_list ::=
		expression
	|	argument_list COMMA expression
	;

// functions defenition that returns
func_def_retrn ::= FDEF ID LPAREN param_list RPAREN COLON type LCBRACK body_op return_statement RCBRACK {: System.out.println("func_def_return ::= FDEF ID LPAREN..."); :}
	| FDEF ID LPAREN param_list RPAREN COLON simple_name LCBRACK body_op return_statement RCBRACK {: System.out.println("func_def_return ::= FDEF ID LPAREN...return type:ID"); :};
//function defenition that doesnt return 
func_def_noretrn ::= FDEF ID LPAREN param_list RPAREN COLON VOID LCBRACK body_op RCBRACK {: System.out.println("func_def_noreturn ::= FDEF ID LPAREN..."); :};
//the body of a statement or function
body ::= declarations_list statement_list {: System.out.println("body ::= var_declr statement_list"); :}
	| statement_list
	| declarations_list;
	
body_op ::= 
	| body;
//parameters list when defining a function
param_list ::= {: System.out.println("param_list ::= "); :}
	| element_list  {: System.out.println("param_list ::= element_list"); :};	


return_statement ::= RETURN expression SEMI {: System.out.println("return_statement ::= RETURN expression SEMI"); :};


method_invocation ::=
		name LPAREN argument_list_opt RPAREN
	;
list_index ::=
		name LBRACK additive_expression RBRACK
	;
postfix_expression ::= 
		primary {: System.out.println("postfix_expression ::= primary"); :}
	|	name {: System.out.println("postfix_expression ::= name"); :}
	;

unary_expression ::=
		unary_expression_not_plus_minus {: System.out.println("unary_expression ::= unary_expression_not_plus_minus"); :}
	;

unary_expression_not_plus_minus ::=
		postfix_expression {: System.out.println("unary_expression_not_plus_minus::= postfix_expression"); :}
	|	NOT unary_expression 
	;

multiplicative_expression ::=
		unary_expression {: System.out.println("multiplicative_expression ::= unary_expression"); :}
	|	multiplicative_expression TIMES unary_expression
	|	multiplicative_expression DIVIDE unary_expression
	;
additive_expression ::=
		multiplicative_expression {: System.out.println("additive_expression ::= multiplicative_expression"); :}
	|	additive_expression PLUS multiplicative_expression {: System.out.println("additive_expression ::= additive_expression PLUS multiplicative_expression"); :}
	|	additive_expression MINUS multiplicative_expression
	;
shift_expression ::=
		additive_expression {: System.out.println("shift_expression ::= additive_expression"); :}
	;
relational_expression ::=
		shift_expression {: System.out.println("relational_expression ::= shift_expression"); :}
	|	relational_expression LESS shift_expression
	|	relational_expression GREATER shift_expression
	|	relational_expression LESSEQ shift_expression
	|	relational_expression GREATEREQ shift_expression
	;
equality_expression ::=
		relational_expression {: System.out.println("equality_expression ::= relational_expression"); :}
	|	equality_expression EQ relational_expression
	|	equality_expression NEQ relational_expression
	;
and_expression ::= 
		equality_expression {: System.out.println("and_expression ::= equality_expression"); :}
	|	and_expression AND equality_expression
	;

conditional_or_expression ::=
		and_expression {: System.out.println("conditional_or_expression ::= and_expression"); :}
	|	conditional_or_expression OR and_expression
	;
conditional_expression ::= 
		conditional_or_expression {: System.out.println("conditional_expression ::= conditional_or_expression"); :}
	;
assignment_expression ::= 
		conditional_expression {: System.out.println("assignment_expression ::= conditional_expression"); :}
		| concat_expr
		| in_expression
		| sequence_slicing
	;
assignment ::=	left_hand_side ASSIGN assignment_expression {: System.out.println("assignment ::= left_hand_side ASSIGN assignment_expression"); :}
	;
left_hand_side ::= 
		name {: System.out.println("left_hand_side ::= name"); :}
	;

concat_expr ::= name CONCAT name
	| name CONCAT list
	| list CONCAT name
	| list CONCAT list
	| list CONCAT concat_expr
	| name CONCAT concat_expr
	| name CONCAT sequence_slicing
	| sequence_slicing CONCAT name
	| sequence_slicing CONCAT sequence_slicing
	| sequence_slicing CONCAT concat_expr;
	//sequence length, i.e len(sq)
sequence_len ::= LEN LPAREN name RPAREN {:System.out.println("sequence_len ::= LEN LPAREN name RPAREN");:};
//sequence slicing, i.e sq[1:2] or sq[j:i]
sequence_slicing ::= name LBRACK additive_expression COLON additive_expression RBRACK {:System.out.println("sequence_slicing ::= name LBRACK ar_expression COLON ar_expression RBRACK");:}
	| name LBRACK COLON additive_expression RBRACK {:System.out.println("sequence_slicing ::= name LBRACK COLON ar_expression RBRACK");:}
	| name LBRACK additive_expression COLON RBRACK {:System.out.println("sequence_slicing ::= name LBRACK ar_expression COLON RBRACK");:};
//in operator
in_expression ::= value IN list
	| value IN name
	| name IN name;

expression ::=	assignment_expression {: System.out.println("expression ::= assignment_expression"); :}
	;

//if statement
if_statement ::= IF LPAREN expression RPAREN  LCBRACK body_op RCBRACK else_opt {: System.out.println("if_statement ::= IF LPAREN bool_exp RPAREN LCBRACK..."); :};
//else statement
else_statement ::= ELSE LCBRACK body_op RCBRACK {: System.out.println("else_statement ::= ELSE LCBRACK body RCBRACK"); :};
// else optional
else_opt ::= {: System.out.println("else_opt ::= "); :}
	| else_statement {: System.out.println("else_opt ::= else_statement"); :};
//while statement
while_statement ::= WHILE LPAREN expression RPAREN DO LCBRACK body_op RCBRACK {: System.out.println("while_statement ::= ..."); :};
//repeat statement
repeat_statement ::= REPEAT LCBRACK body_op RCBRACK UNTIL LPAREN expression RPAREN {: System.out.println("repeat_statement ::= ..."); :};
//statement 
statement ::= assignment SEMI {: System.out.println("statement ::= assingment"); :}
	| method_invocation SEMI {: System.out.println("statement ::= func_call"); :}
	| if_statement {: System.out.println("statement ::= if_statement"); :}
	| while_statement {: System.out.println("statement ::= while_statement"); :}
	| repeat_statement SEMI{: System.out.println("statement ::= repeat_statement"); :};
//	| return_statement {: System.out.println("statement ::= return_statement"); :};
// statement list
statement_list ::= statement {: System.out.println("statement_list ::= statement_list statement"); :}
	| statement_list statement {: System.out.println("statement_list ::= statement"); :};

program ::= declarations_list LCBRACK body RCBRACK
	| LCBRACK body RCBRACK;