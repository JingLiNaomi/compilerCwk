import java_cup.runtime.*;
import java.util.*;
import java.io.*;


// operations
terminal PLUS, TIMES, MINUS,DIVIDE, CONCAT, ASSIGN;
//types
terminal FLOAT, INTEGER,STRING,CHAR,BOOL, ID;
//type definitions
terminal FLOATTYPE, INTEGERTYPE, STRINGTYPE, CHARTYPE, LISTTYPE, TUPLETYPE, BOOLTYPE; 
// punctutation
terminal  DOT, COMMA, COLON, STROKE,LCBRACK, RCBRACK,LPAREN, RPAREN,SEMI,LBRACK,RBRACK;
//keywords
terminal LEN, VOID,FDEF, IF, ELSE, WHILE, REPEAT, RETURN, UNTIL, DO;
//logica operations
terminal OR, AND, NOT;
//comparison
terminal EQ, LESS, GREATER, LESSEQ, GREATEREQ, NEQ;
//data type declaration
terminal TDEF;  

non-terminal name, simple_name, qualified_name, type, element;
non terminal typedecl,typedeclist,elementlist;   //Data type declaration
non-terminal list, emptyList, listOfListsOfStrings, listOfListsOfIntegers, listOfListsOfFloats, listOfListsOfChars,valuelist, value;
non-terminal stringList, floatList, integerList, charList;
non-terminal listOfChars, listOfIntegers, listOfFloats, listOfStrings,listOfAnyElements,anyElement;
non-terminal tuple, tuple_op, comma_op, emptyTuple;
non-terminal list_index, sequence_len, sequence_slicing;

non terminal ar_operation, ar_expression, ar_operand, expression;
non-terminal comparison_exp, comp_operand, comparison_op;

non-terminal bool_exp, bool_operand, logic_operation, logic_expr;

non-terminal concat_expr, concat_operand;

non-terminal assignment, if_statement, else_statement, else_opt, while_statement, repeat_statement, return_statement;



non-terminal func_def_retrn, func_def_noretrn, func_body, param_list, actual_param_list, func_call, body;
non-terminal var_declr, statement, statement_list,vardeclist, var_single_declr, var_declr_init;


precedence left PLUS;
precedence left TIMES;



start with statement_list;

// name. can be name of variable or name of function
name	::=	simple_name {:System.out.println("name ::= simple_name");:}
	|	qualified_name {:System.out.println("name ::= qualified_name");:} ;
type ::= FLOATTYPE {:System.out.println("type ::= FLOATTYPE");:}
	| INTEGERTYPE {:System.out.println("type ::= INTEGERTYPE");:}
	| CHARTYPE {:System.out.println("type ::= CHARTYPE");:}
	| BOOLTYPE {:System.out.println("type ::= BOOLTYPE");:}
	| STRINGTYPE {:System.out.println("type ::= STRINGTYPE");:}
	| LISTTYPE {:System.out.println("type ::= LISTTYPE");:}
	| TUPLETYPE {:System.out.println("type ::= TUPLETYPE");:}; 
//simple name, i.e ID
simple_name ::=	ID {:System.out.println("simple_name ::= ID");:};
//compound name, i.e id.field
qualified_name ::=
		name DOT ID {:System.out.println("qualified_name ::= name DOT ID");:}
		| list_index {:System.out.println("qualified_name ::= list_index");:};

//any list
list ::= emptyList {:System.out.println("list ::= emptyList");:}
	| stringList {:System.out.println("list ::= stringList");:}
	| integerList {:System.out.println("list ::= integerList");:}
	| floatList {:System.out.println("list ::= floatList");:};
//empty list, i.e []
emptyList ::= LBRACK RBRACK {:System.out.println("emptyList ::= LBRACK RBRACK");:};
//string list, i.e ["item1","item2"] or [["item1"],["item2"]] etc
stringList ::= LBRACK listOfStrings RBRACK {:System.out.println("stringList ::= LBRACK listOfStrings RBRACK");:}
	| LBRACK listOfListsOfStrings RBRACK {:System.out.println("stringList ::= LBRACK listOfListsOfStrings RBRACK");:}; 
//list of lists of strings, i.e ["item1"],["item2"]
listOfListsOfStrings ::= stringList {:System.out.println("listOfListsOfStrings ::= stringList");:}
	| stringList COMMA listOfListsOfStrings {:System.out.println("listOfListsOfStrings ::= stringList COMMA listOfListsOfStrings");:};
//list of strings, i.e "item1","item2"
listOfStrings ::= STRING {:System.out.println("listOfStrings ::= STRING");:}
	| STRING COMMA listOfStrings {:System.out.println("listOfStrings ::= STRING COMMA listOfStrings");:};
//integer list, i.e [1,2,3] or [[1],[2],[3]] etc
integerList ::= LBRACK listOfIntegers RBRACK {:System.out.println("integerList ::= LBRACK listOfIntegers RBRACK");:}
	| LBRACK listOfListsOfIntegers RBRACK {:System.out.println("integerList ::= LBRACK listOfListsOfIntegers RBRACK");:}; 
//list of list of integers, i.e [1,2,3],[1,2,3]
listOfListsOfIntegers ::= integerList {:System.out.println("listOfListsOfIntegers ::= integerList");:}
	| integerList COMMA listOfListsOfIntegers {:System.out.println("listOfListsOfIntegers ::= integerList COMMA listOfListsOfIntegers ");:};
//list of integers, i.e 1,2,3
listOfIntegers ::= INTEGER {:System.out.println("listOfIntegers ::= INTEGER");:}
	| INTEGER COMMA listOfIntegers {:System.out.println("listOfIntegers ::= INTEGER COMMA listOfIntegers");:};
//float list, i.e [1.2,3.4,1.5] or [[2.4],[2.2],[5.3]] etc
floatList ::= LBRACK listOfFloats RBRACK {:System.out.println("floatList ::= LBRACK listOfFloats RBRACK");:}
	| LBRACK listOfListsOfFloats RBRACK {:System.out.println("floatList ::= LBRACK listOfListsOfFloats RBRACK");:}; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfFloats ::= floatList {:System.out.println("listOfListsOfFloats ::= floatList");:}
	| floatList COMMA listOfListsOfFloats {:System.out.println("listOfListsOfFloats ::= floatList COMMA listOfListsOfFloats");:};
// list of floats, i.e 2.6,4.2,6.2
listOfFloats ::= FLOAT {:System.out.println("listOfFloats ::= FLOAT");:}
	| FLOAT COMMA listOfFloats {:System.out.println("listOfFloats ::= FLOAT COMMA listOfFloats");:};


//char list, i.e ['1','4','5'] or [['s'],['e'],['d']] etc
charList ::= LBRACK listOfChars RBRACK {:System.out.println("charList ::= LBRACK listOfChars RBRACK");:}
	| LBRACK listOfListsOfChars RBRACK {:System.out.println("charList ::= LBRACK listOfListsOfChars RBRACK");:}; 
//list of list of chars, i,e ['4','2','d'], ['e','5','s']
listOfListsOfChars ::= charList {:System.out.println("listOfListsOfChars ::= charList");:}
	| charList COMMA listOfListsOfChars {:System.out.println("listOfListsOfChars ::= charList COMMA listOfListsOfChars");:};
// list of chars, i.e '2','3','j'
listOfChars ::= CHAR {:System.out.println("listOfChars ::= CHAR");:}
	| CHAR COMMA listOfChars {:System.out.println("listOfChars ::= CHAR COMMA listOfChars");:};


//any element
anyElement ::= INTEGER {:System.out.println("anyElement ::= INTEGER");:}
	| FLOAT  {:System.out.println("anyElement ::= FLOAT");:}
	| STRING {:System.out.println("anyElement ::= STRING");:}
	| CHAR {:System.out.println("anyElement ::= CHAR");:}
	| BOOL {:System.out.println("anyElement ::= BOOL");:}
	| list {:System.out.println("anyElement ::= list");:}; 
// any element list
/*anyElemList ::= LBRACK listOfAnyElems RBRACK 
	| LBRACK listOfListsOfAnyElems RBRACK; 
//list of list of 
listOfListsOfAnyElems ::= anyElemList
	| anyElemList COMMA listOfListsOfAnyElems;*/

listOfAnyElements ::= anyElement {:System.out.println("listOfAnyElements ::= anyElement");:}
	| listOfAnyElements COMMA anyElement {:System.out.println("listOfAnyElements ::= listOfAnyElements COMMA anyElement");:};

//empty tuple
emptyTuple ::= LBRACK STROKE STROKE RBRACK {:System.out.println("emptyTuple ::= LBRACK STROKE STROKE RBRACK ");:};
//tupple
tuple ::= emptyTuple  {:System.out.println("tuple ::= emptyTuple");:}
	| LBRACK STROKE listOfAnyElements STROKE RBRACK {:System.out.println("tuple ::= LBRACK STROKE listOfAnyElements STROKE RBRACK");:}
	| LBRACK STROKE tuple comma_op tuple_op STROKE RBRACK {:System.out.println("tuple ::= LBRACK STROKE listOfAnyElements STROKE RBRACK");:};
// comma optional
comma_op ::=  {:System.out.println("comma_op ::= emptyString");:}
	| COMMA {:System.out.println("comma_op ::= COMMA");:};
//tuple optional
tuple_op ::= {:System.out.println("tuple_op ::= emptyString");:}
	| tuple {:System.out.println("tuple_op ::= tuple");:};
// list indexing, i.e a[2]
list_index ::= name LBRACK ar_operand RBRACK {:System.out.println("list_index ::= name LBRACK ar_operand RBRACK");:}
	| name LBRACK ar_expression RBRACK {:System.out.println("list_index ::= name LBRACK ar_expression RBRACK");:};
//sequence length, i.e len(sq)
sequence_len ::= LEN LPAREN name RPAREN {:System.out.println("sequence_len ::= LEN LPAREN name RPAREN");:};
//sequence slicing, i.e sq[1:2] or sq[j:i]
sequence_slicing ::= name LBRACK ar_expression COLON ar_expression RBRACK {:System.out.println("sequence_slicing ::= name LBRACK ar_expression COLON ar_expression RBRACK");:}
	| name LBRACK COLON ar_expression RBRACK {:System.out.println("sequence_slicing ::= name LBRACK COLON ar_expression RBRACK");:}
	| name LBRACK ar_expression COLON RBRACK {:System.out.println("sequence_slicing ::= name LBRACK ar_expression COLON RBRACK");:};

//ariphmentic operations	
ar_operation ::= PLUS {: System.out.println("Ariphmentic operation +"); :}
	| MINUS {: System.out.println("Ariphmentic operation -"); :}
	| DIVIDE {: System.out.println("Ariphmentic operation /"); :}
	| TIMES {: System.out.println("Ariphmentic operation *"); :};
//ariphmetic operand in ar expression
ar_operand ::= 
	 func_call {: System.out.println("ar_operand ::= func_call"); :}
	| INTEGER {: System.out.println("ar_operand ::= INTEGER"); :}
	| FLOAT {: System.out.println("ar_operand ::= FLOAT"); :};
// ariphmetic expression
ar_expression ::= ar_operand ar_operation ar_operand {: System.out.println("Ariphmentic expression ar_operand ar_operation ar_operand"); :}
	| name ar_operation ar_operand {: System.out.println("Ariphmentic expression name ar_operation ar_operand"); :}
	| ar_operand ar_operation name {: System.out.println("Ariphmentic expression ar_operand ar_operation name"); :}
	| name ar_operation name {: System.out.println("Ariphmentic expression ar_operand ar_operation ar_operand"); :}
	| ar_expression ar_operation ar_operand {: System.out.println("Ariphmentic expression ar_expression ar_operation ar_operand"); :}
	| ar_expression ar_operation name {: System.out.println("Ariphmentic expression ar_expression ar_operation name"); :}
	| LPAREN ar_expression RPAREN {: System.out.println("Ariphmentic expression LPAREN ar_expression LPAREN"); :};
//comparison expression
comparison_exp ::= comp_operand comparison_op comp_operand {: System.out.println("comparison_exp ::= comp_operand comparison_op comp_operand"); :};

//comparison operation 
comparison_op ::= EQ {: System.out.println("comparison_op ::= EQ"); :}
	| NEQ {: System.out.println("comparison_op ::= NEQ"); :}
	| LESS {: System.out.println("comparison_op ::= LESS"); :} 
	| LESSEQ {: System.out.println("comparison_op ::= LESSEQ"); :}
	| GREATER {: System.out.println("comparison_op ::= GREATER"); :}
	| GREATEREQ {: System.out.println("comparison_op ::= GREATEREQ"); :};
//comparison operand
comp_operand ::= name {: System.out.println("comp_operand ::= name"); :}
	| ar_operand {: System.out.println("comp_operand ::= ar_operand"); :}
	| ar_expression {: System.out.println("comp_operand ::= ar_expression"); :};	
//boolean operand in boolean expression
bool_operand ::= 
	comparison_exp {: System.out.println("bool_operand ::= comparison_exp"); :};
//logical operation
logic_operation ::= OR {: System.out.println("logic_operation ::= OR"); :}
	| AND {: System.out.println("logic_operation ::= AND"); :}
	| NOT {: System.out.println("logic_operation ::= NOT"); :};

//logical expression
logic_expr ::= 
	comparison_exp logic_operation comparison_exp {: System.out.println("logic_expr ::= comparison_exp logic_operation comparison_exp"); :}
	| name logic_operation name {: System.out.println("logic_expr ::= name logic_operation name"); :}
	| comparison_exp logic_operation name {: System.out.println("logic_expr ::= comparison_exp logic_operation name"); :}
	| name logic_operation comparison_exp {: System.out.println("logic_expr ::= name logic_operation comparison_exp"); :};
//boolean expression
bool_exp ::= comparison_exp {: System.out.println("bool_exp ::= comparison_exp"); :}
	| logic_expr {: System.out.println("bool_exp ::= logic_exp"); :};

//concatenation operand
concat_operand ::= 
	 list {: System.out.println("concat_operand ::= list"); :};
//concatenation expression
concat_expr ::= concat_operand CONCAT concat_operand {: System.out.println("concat_expr ::= concat_operand CONCAT concat_operand"); :}
	| name CONCAT concat_operand {: System.out.println("concat_expr ::= concat_operand CONCAT concat_operand"); :}
	| concat_operand CONCAT name {: System.out.println("concat_expr ::= concat_operand CONCAT name"); :}
	| name CONCAT name {: System.out.println("concat_expr ::= name CONCAT name"); :}
	| concat_expr CONCAT name {: System.out.println("concat_expr ::= concat_expr CONCAT name"); :}
	| concat_expr CONCAT concat_operand {: System.out.println("concat_expr ::= concat_expr CONCAT concat_operand"); :};
//expression
expression ::= ar_expression {: System.out.println("expression ::= ar_expression"); :}
	| bool_exp {: System.out.println("expression ::= bool_exp"); :}
	| concat_expr {: System.out.println("expression ::= concat_exp"); :};

// functions defenition that returns
func_def_retrn ::= FDEF ID LPAREN param_list RPAREN COLON type LCBRACK func_body return_statement RCBRACK {: System.out.println("func_def_return ::= FDEF ID LPAREN..."); :};
//function defenition that doesnt return 
func_def_noretrn ::= FDEF ID LPAREN param_list RPAREN COLON VOID LCBRACK func_body RCBRACK {: System.out.println("func_def_noreturn ::= FDEF ID LPAREN..."); :};
//the body of a statement or function
body ::= var_declr statement_list {: System.out.println("body ::= var_declr statement_list"); :};
//parameters list when defining a function
param_list ::= name COLON type {: System.out.println("param_list ::= name COLON type"); :}
	| name COLON type COMMA param_list {: System.out.println("param_list ::= name COLON type COMMA param_list"); :};
//actual parameters list when calling a function
actual_param_list ::= expression {: System.out.println("actual_param_list ::= expression"); :}
	| expression COMMA actual_param_list {: System.out.println("actual_param_list ::= expression COMMA actual_param_list"); :};

//function call
func_call ::= ID LPAREN actual_param_list RPAREN {: System.out.println("func_call ::= ID LPAREN actual_param_list RPAREN"); :};
//assignment statement
assignment ::= name ASSIGN name SEMI {: System.out.println("assignment ::= name ASSIGN name SEMI"); :}
	| name ASSIGN expression SEMI {: System.out.println("assignment ::= name ASSIGN expression SEMI"); :}
	| name ASSIGN anyElement SEMI {: System.out.println("assignment ::= name ASSIGN anyElement SEMI"); :};
//if statement
if_statement ::= IF LPAREN bool_exp RPAREN  LCBRACK body RCBRACK else_opt {: System.out.println("if_statement ::= IF LPAREN bool_exp RPAREN LCBRACK..."); :};
//else statement
else_statement ::= ELSE LCBRACK body RCBRACK {: System.out.println("else_statement ::= ELSE LCBRACK body RCBRACK"); :};
// else optional
else_opt ::= {: System.out.println("else_opt ::= "); :}
	| else_statement {: System.out.println("else_opt ::= else_statement"); :};
//while statement
while_statement ::= WHILE LPAREN bool_exp RPAREN DO LCBRACK body RCBRACK {: System.out.println("while_statement ::= ..."); :};
//repeat statement
repeat_statement ::= REPEAT LCBRACK body RCBRACK UNTIL LPAREN bool_exp RPAREN {: System.out.println("repeat_statement ::= ..."); :};
//return statement
return_statement ::= RETURN expression SEMI {: System.out.println("return_statement ::= RETURN expression SEMI"); :}
	| RETURN name SEMI {: System.out.println("return_statement ::= RETURN name SEMI"); :};





//statement 
statement ::= assignment {: System.out.println("statement ::= assingment"); :}
	| func_call SEMI {: System.out.println("statement ::= func_call"); :}
	| if_statement {: System.out.println("statement ::= if_statement"); :}
	| while_statement {: System.out.println("statement ::= while_statement"); :}
	| repeat_statement {: System.out.println("statement ::= repeat_statement"); :}
	| return_statement {: System.out.println("statement ::= return_statement"); :};
// statement list
statement_list ::= statement_list statement {: System.out.println("statement_list ::= statement_list statement"); :}
	| statement {: System.out.println("statement_list ::= statement"); :};


//data type declaration
typedeclist ::= typedecl 
		    | typedeclist typedecl;
typedecl ::= TDEF ID COLON elementlist SEMI;	
elementlist ::= element
			| elementlist COMMA element;
element ::= ID COLON type;

//variable declaration
vardeclist ::= var_declr SEMI
		   | vardeclist var_declr SEMI;
var_declr ::= var_single_declr
	      | var_declr_init;
var_single_declr ::= ID COLON type;
var_declr_init ::= ID COLON TUPLETYPE ASSIGN tuple 		
                   | ID COLON INTEGERTYPE ASSIGN INTEGER
				   | ID COLON STRINGTYPE ASSIGN STRING
                   | ID COLON ID ASSIGN valuelist
				   | ID COLON CHARTYPE ASSIGN CHAR 
 				   | ID COLON LISTTYPE ASSIGN list 
				   | ID COLON BOOLTYPE ASSIGN BOOL
				   | ID COLON FLOATTYPE ASSIGN FLOAT; 
valuelist ::= value
			| valuelist value;
			
value ::= BOOL
	  | INTEGER
	  | FLOAT
	  | CHAR
	  | STRING
	  | list
	  | tuple;