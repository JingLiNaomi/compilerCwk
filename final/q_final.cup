import java_cup.runtime.*;
import java.util.*;
import java.io.*;


parser code {:
static boolean parser_successful=true;

static String section="Declaration";
//static java_cup.runtime.Scanner s = this.getScanner();

static String[] errs = {"list defenition","tuple defenition","user defined data declaration"};
static int st=0;
:};
// operations
terminal PLUS, TIMES, MINUS,DIVIDE, CONCAT, ASSIGN;
//types
terminal FLOAT, INTEGER,STRING,CHAR,BOOL, ID;
//type definitions
terminal FLOATTYPE, INTEGERTYPE, STRINGTYPE, CHARTYPE, LISTTYPE, TUPLETYPE, BOOLTYPE; 
// punctutation
terminal  DOT, COMMA, COLON, STROKE,LCBRACK, RCBRACK,LPAREN, RPAREN,SEMI,LBRACK,RBRACK;
//keywords
terminal LEN, VOID,FDEF, IF, ELSE, WHILE, REPEAT, RETURN, UNTIL, DO, IN;
//logica operations
terminal OR, AND, NOT;
//comparison
terminal EQ, LESS, GREATER, LESSEQ, GREATEREQ, NEQ;
//data type declaration
terminal TDEF;
terminal ILLEGALCHAR;  


non terminal name, simple_name, qualified_name, type, element;
non terminal type_declr,element_list;   //Data type declaration
non terminal list, emptyList, listOfListsOfStrings, listOfListsOfIntegers, listOfListsOfFloats, listOfListsOfChars,valuelist, listOfListsOfBools, listOfListsOfVars, value;
non terminal stringList, floatList, integerList, charList,boolList,varList;
non terminal listOfChars, listOfIntegers, listOfFloats, listOfStrings, listOfBools, listOfVars;
non terminal tuple, emptyTuple;
non terminal list_index, sequence_len, sequence_slicing, in_expression;

non terminal expression,primary,primary_no_new_array,multiplicative_expression,additive_expression;

non terminal concat_expr;

non terminal assignment, if_statement, else_statement, else_opt, while_statement, repeat_statement, return_statement;



nonterminal func_def_retrn, func_def_noretrn, param_list, body, body_op, method_invocation;
non terminal var_declr, statement, statement_list, variable_declarator, variable_initializer,argument_list,argument_list_opt;

non terminal unary_expression,postfix_expression,shift_expression, relational_expression,equality_expression;
non terminal conditional_expression, conditional_or_expression, assignment_expression, left_hand_side, and_expression;

non terminal declaration, declarations_list, program, main,local_var_declaration_list;


precedence left PLUS;
precedence left TIMES;

start with program;

name ::= simple_name 
	|	qualified_name 
	;
simple_name ::=	ID 
	;
//compound name, i.e id.field
qualified_name ::= name DOT ID
	| list_index 
	;

value ::= BOOL 
	| INTEGER 
	| FLOAT 
	| CHAR 
	| STRING 
	;
valuelist ::= value 
	| valuelist COMMA value 
	;
//any list
list ::= emptyList 
	| stringList 
	| integerList 
	| floatList 
	| charList 
	| boolList 
	| varList 
	;
//empty list, i.e []
emptyList ::= LBRACK RBRACK 
	;
//string list, i.e ["item1","item2"] or [["item1"],["item2"]] etc
stringList ::= LBRACK listOfStrings RBRACK 
	| LBRACK listOfListsOfStrings RBRACK 
	; 
//list of lists of strings, i.e ["item1"],["item2"]
listOfListsOfStrings ::= stringList 
	| stringList COMMA listOfListsOfStrings
	;
//list of strings, i.e "item1","item2"
listOfStrings ::= STRING 
	| STRING COMMA listOfStrings 
	;
//integer list, i.e [1,2,3] or [[1],[2],[3]] etc
integerList ::= LBRACK listOfIntegers RBRACK 
	| LBRACK listOfListsOfIntegers RBRACK 
	; 
//list of list of integers, i.e [1,2,3],[1,2,3]
listOfListsOfIntegers ::= integerList 
	| integerList COMMA listOfListsOfIntegers 
	;
//list of integers, i.e 1,2,3
listOfIntegers ::= INTEGER 
	| INTEGER COMMA listOfIntegers 
	;
//float list, i.e [1.2,3.4,1.5] or [[2.4],[2.2],[5.3]] etc
floatList ::= LBRACK listOfFloats RBRACK 
	| LBRACK listOfListsOfFloats RBRACK 
	; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfFloats ::= floatList 
	| floatList COMMA listOfListsOfFloats 
	;
// list of floats, i.e 2.6,4.2,6.2
listOfFloats ::= FLOAT 
	| FLOAT COMMA listOfFloats 
	;
//float list, i.e [1.2,3.4,1.5] or [[2.4],[2.2],[5.3]] etc
boolList ::= LBRACK listOfBools RBRACK 
	| LBRACK listOfListsOfBools RBRACK 
	; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfBools ::= boolList 
	| boolList COMMA listOfListsOfBools 
	;
// list of floats, i.e 2.6,4.2,6.2
listOfBools ::= BOOL
	| BOOL COMMA listOfBools 
	;
// list of variables
varList ::= LBRACK listOfVars RBRACK 
	| LBRACK listOfListsOfVars RBRACK
	; 
//list of list of floats, i,e [1.2,3.4,1.5], [1.2,3.4,1.5]
listOfListsOfVars ::= varList 
	| varList COMMA listOfListsOfVars 
	;
// list of floats, i.e 2.6,4.2,6.2
listOfVars ::= name 
	| name COMMA listOfVars
	;


//char list, i.e ['1','4','5'] or [['s'],['e'],['d']] etc
charList ::= LBRACK listOfChars RBRACK 
	| LBRACK listOfListsOfChars RBRACK 
	; 
//list of list of chars, i,e ['4','2','d'], ['e','5','s']
listOfListsOfChars ::= charList 
	| charList COMMA listOfListsOfChars
	;
// list of chars, i.e '2','3','j'
listOfChars ::= CHAR 
	| CHAR COMMA listOfChars
	;

//empty tuple
emptyTuple ::= LBRACK OR RBRACK 
	;
//tupple
tuple ::= emptyTuple  
	| LBRACK STROKE valuelist STROKE RBRACK 
	;


declaration ::= 
	 type_declr
	| var_declr
	| func_def_retrn
	| func_def_noretrn
	;

<<<<<<< HEAD
declarations_list ::= declarations_list declaration {:parser.section="declaration list";:}
	| declaration 
=======
declarations_list ::= declarations_list declaration 
	| declaration 

>>>>>>> Merge commit
	;


type_declr ::= TDEF ID COLON element_list SEMI
	| TDEF ID COLON error SEMI {:System.out.println("Error is in element_list"); parser.parser_successful=false;:} 
	| TDEF error SEMI {:System.out.println("Error is in type_declr"); parser.parser_successful=false;:} 
	;	
	
element_list ::= element 
	| element_list COMMA element 
	| error COMMA element  {:System.out.println("Error is in element_list"); parser.parser_successful=false;:} 
	;
	
element ::= ID COLON type 
	| ID COLON ID
	;

var_declr ::=  variable_declarator SEMI 
	;
	
variable_declarator ::= element 
	|	element ASSIGN variable_initializer 
	| 	element ASSIGN error {:System.out.println("Error is in variable_initializer"); parser.parser_successful=false;:} 
	;
	
	
variable_initializer ::= expression 
	| list 
	| tuple 
	| variable_initializer COMMA expression
	| error COMMA expression {:System.out.println("Error is in variable_initializer"); parser.parser_successful=false;:} 
	| variable_initializer COMMA list
	| variable_initializer COMMA tuple
	;	

type ::= FLOATTYPE 
	| INTEGERTYPE 
	| CHARTYPE 
	| BOOLTYPE 
	| STRINGTYPE 
	| LISTTYPE 
	| TUPLETYPE 
	;

// 19.12) Expressions
primary ::=	primary_no_new_array 
	;
primary_no_new_array ::= value 
	|	LPAREN expression RPAREN
	|   sequence_len
	|	method_invocation
	| LPAREN error RPAREN {:System.out.println("Error is in primary expression"); parser.parser_successful=false;:}
	;


argument_list_opt ::=
	|	argument_list
	;
argument_list ::=
		expression
	|	argument_list COMMA expression
	| argument_list COMMA error {:System.out.println("Error is in argument list"); parser.parser_successful=false;:}
	;

// functions defenition that returns
func_def_retrn ::= FDEF ID LPAREN param_list RPAREN COLON type LCBRACK body_op return_statement RCBRACK 
	| FDEF ID LPAREN param_list RPAREN COLON simple_name LCBRACK body_op return_statement RCBRACK 
	;
//function defenition that doesnt return 
func_def_noretrn ::= FDEF ID LPAREN param_list RPAREN COLON VOID LCBRACK body_op RCBRACK 
	;
//the body of a statement or function
body ::= local_var_declaration_list statement_list 
	| statement_list
	| local_var_declaration_list
	;

body_op ::= 
	| body
	;

local_var_declaration_list ::= local_var_declaration_list var_declr {:parser.section="main";:}
	| var_declr {:parser.section="main";:}
	;

//parameters list when defining a function
param_list ::= 
	| element_list  
	| element_list error {:System.out.println("Error is in parameters list"); parser.parser_successful=false;:}
	| error element_list {:System.out.println("Error is in parameters list"); parser.parser_successful=false;:}
	;	


return_statement ::= RETURN expression SEMI 
	| RETURN error SEMI {:System.out.println("Error is in return statement"); parser.parser_successful=false;:}
	;


method_invocation ::= name LPAREN argument_list_opt RPAREN
	;
list_index ::= name LBRACK additive_expression RBRACK
	| name LBRACK error RBRACK {:System.out.println("Error is in list indexing"); parser.parser_successful=false;:}
	;
postfix_expression ::= primary 
	|	name 
	;

unary_expression ::= postfix_expression 
	|	NOT unary_expression 
	;

multiplicative_expression ::= unary_expression 
	|	multiplicative_expression TIMES unary_expression
	|	multiplicative_expression DIVIDE unary_expression
	| error TIMES error {:System.out.println("Error is in Multiplicative expression"); parser.parser_successful=false;:}
	| error DIVIDE error {:System.out.println("Error is in Multiplicative expression"); parser.parser_successful=false;:}
	;
additive_expression ::= multiplicative_expression 
	|	additive_expression PLUS multiplicative_expression 
	|	additive_expression MINUS multiplicative_expression
	| additive_expression PLUS error {:System.out.println("Error is in Additive expression"); parser.parser_successful=false;:}
	| error MINUS error {:System.out.println("Error is in Additive expression"); parser.parser_successful=false;:} 
	;
shift_expression ::= additive_expression 
	;
relational_expression ::= shift_expression 
	|	relational_expression LESS shift_expression
	|	error LESS shift_expression	{:System.out.println("Error is in relational_expression"); parser.parser_successful=false;:} 
	|	relational_expression GREATER shift_expression 
	|	error GREATER shift_expression {:System.out.println("Error is in relational_expression"); parser.parser_successful=false;:} 
	|	relational_expression LESSEQ shift_expression
	|	error LESSEQ shift_expression  {:System.out.println("Error is in relational_expression"); parser.parser_successful=false;:} 
	|	relational_expression GREATEREQ shift_expression
	|	error GREATEREQ shift_expression  {:System.out.println("Error is in relational_expression"); parser.parser_successful=false;:} 
	;
equality_expression ::= relational_expression 
	|	equality_expression EQ relational_expression
	|	error EQ relational_expression {:System.out.println("Error is in equality_expression"); parser.parser_successful=false;:} 
	|	equality_expression NEQ relational_expression
	|	error NEQ relational_expression  {:System.out.println("Error is in equality_expression"); parser.parser_successful=false;:} 
	;
and_expression ::= equality_expression 
	|	and_expression AND equality_expression
	|	error AND equality_expression {:System.out.println("Error is in and_expression"); parser.parser_successful=false;:} 
	;

conditional_or_expression ::= and_expression
	|	conditional_or_expression OR and_expression
	|	error OR and_expression {:System.out.println("Error is in conditional_or_expression"); parser.parser_successful=false;:} 
	;
conditional_expression ::= conditional_or_expression
	;
assignment_expression ::= conditional_expression 
	| concat_expr
	| in_expression
	| sequence_slicing
//	| ILLEGALCHAR {:System.out.println("Error is in Multiplicative expression"); parser.parser_successful=false;:}
	;
<<<<<<< HEAD
assignment ::=	left_hand_side ASSIGN assignment_expression 
	| error ASSIGN assignment_expression {:System.out.println("Error is in left_hand_side"); parser.parser_successful=false;:} 
//	| left_hand_side ASSIGN error {:System.out.println("Error is on the right hand side of Assignment ");:}
//	| error ASSIGN assignment_expression {:System.out.println("Error is on the left hand side of Assignment ");:};
	;
=======
assignment ::=	left_hand_side ASSIGN assignment_expression ;
//	| left_hand_side ASSIGN error {:System.out.println("Error is on the right hand side of Assignment ");:};
	//| error ASSIGN assignment_expression {:System.out.println("Error is on the left hand side of Assignment ");:};

>>>>>>> Merge commit
left_hand_side ::= 	name 
	;

concat_expr ::= name CONCAT name
	| name CONCAT list
	| list CONCAT name
	| list CONCAT list
	| list CONCAT concat_expr
	| name CONCAT concat_expr
	| name CONCAT sequence_slicing
	| sequence_slicing CONCAT name
	| sequence_slicing CONCAT sequence_slicing
	| sequence_slicing CONCAT concat_expr
	| error CONCAT error {:System.out.println("Error is in Concatentation expression");:}
	;
//sequence length, i.e len(sq)
sequence_len ::= LEN LPAREN name RPAREN 
	| LEN LPAREN error RPAREN {:System.out.println("Error is in sequence length");:}
	;
//sequence slicing, i.e sq[1:2] or sq[j:i]
sequence_slicing ::= name LBRACK additive_expression COLON additive_expression RBRACK 
	| name LBRACK COLON additive_expression RBRACK 
	| name LBRACK additive_expression COLON RBRACK 
	| name LBRACK error COLON error RBRACK {:System.out.println("Error is in sequence slicing");:}
	;
//in operator
in_expression ::= value IN list
	| value IN name
	| name IN name
	| error IN error {:System.out.println("Error is in IN expression");:}
	;

expression ::=	assignment_expression 
	;

//if statement
if_statement ::= IF LPAREN expression RPAREN  LCBRACK body_op RCBRACK else_opt 
	| IF LPAREN error RPAREN LCBRACK body_op RCBRACK else_opt {:System.out.println("Error is in if statement");:}
	;
//else statement
else_statement ::= ELSE LCBRACK body_op RCBRACK 
	;
// else optional
else_opt ::= 
	| else_statement 
	;
//while statement
while_statement ::= WHILE LPAREN expression RPAREN DO LCBRACK body_op RCBRACK 
	;
//repeat statement
repeat_statement ::= REPEAT LCBRACK body_op RCBRACK UNTIL LPAREN expression RPAREN 
	;
//statement 
statement ::= assignment SEMI
	| method_invocation SEMI 
	| if_statement 
	| while_statement
	| repeat_statement SEMI
	;
// statement list
statement_list ::= statement 
	| statement_list statement 
	;

main ::= LCBRACK body RCBRACK {}
	;
program ::= declarations_list main
	| main
	| error {:parser.parser_successful=false;:}
;
